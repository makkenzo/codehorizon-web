<html>
    <head>
        <meta charset="UTF-8" http-equiv="content-type" content="text/html;charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Фон с изображением и квадраты на Canvas</title>
        <style>
            canvas {
                border: 1px solid black;
                display: block;
                margin: 0 auto;
            }
        </style>
        <base
            href="v8config://9b855e8d-e44f-45d1-b03a-5b4a231d0b90/mdobject/id7415a1a4-093a-440f-908e-c2fd63c7b7bb/8eb4fad1-1fa6-403e-970f-2c12dbb43e23"
        />
    </head>
    <body>
        <canvas id="myCanvas" width="5000" height="1500" style="cursor: default"></canvas>
        <script>
            let boxes = [
                {
                    name: 'A1-01',
                    x: 50,
                    y: 50,
                    sizeX: 100,
                    sizeY: 80,
                    selected: false,
                    resizing: false,
                    locked: false,
                    color: 'lightgreen',
                    available: 5,
                    unavailable: 1,
                    total: 10,
                    TypeGUID: 'guid-a1',
                    operationType: '',
                    inZone: true,
                    dimensionless: false,
                },
                {
                    name: 'A1-02',
                    x: 160,
                    y: 50,
                    sizeX: 100,
                    sizeY: 80,
                    selected: false,
                    resizing: false,
                    locked: false,
                    color: 'lightgreen',
                    available: 8,
                    unavailable: 0,
                    total: 10,
                    TypeGUID: 'guid-a1',
                    operationType: '',
                    inZone: true,
                    dimensionless: false,
                },
                {
                    name: 'B2-01',
                    x: 50,
                    y: 150,
                    sizeX: 120,
                    sizeY: 100,
                    selected: true,
                    resizing: false,
                    locked: false,
                    color: 'lightblue',
                    available: 0,
                    unavailable: 0,
                    total: 0,
                    TypeGUID: '',
                    operationType: 'input',
                    inZone: false,
                    dimensionless: false,
                },
                {
                    name: 'C3-01',
                    x: 400,
                    y: 80,
                    sizeX: 80,
                    sizeY: 120,
                    selected: false,
                    resizing: false,
                    locked: false,
                    color: 'lightcoral',
                    available: 8,
                    unavailable: 0,
                    total: 8,
                    TypeGUID: 'guid-c3',
                    operationType: 'output',
                    inZone: false,
                    dimensionless: true,
                },
                {
                    name: 'D4-LOCKED',
                    x: 50,
                    y: 300,
                    sizeX: 100,
                    sizeY: 100,
                    selected: false,
                    resizing: false,
                    locked: true,
                    color: 'grey',
                    available: 0,
                    unavailable: 0,
                    total: 0,
                    TypeGUID: '',
                    operationType: '',
                    inZone: false,
                    dimensionless: false,
                }, // Locked box example
            ];

            let zones = [
                {
                    name: 'Storage Zone A',
                    type: 'Storage',
                    color: 'rgba(255, 223, 186, 0.5)', // Light orange, semi-transparent
                    boxes: [
                        // These define the visual boundary of the zone based on contained boxes
                        {
                            name: 'A1-01',
                            x: boxes[0].x - 6,
                            y: boxes[0].y - 6,
                            sizeX: boxes[0].sizeX + 12,
                            sizeY: boxes[0].sizeY + 12,
                        },
                        {
                            name: 'A1-02',
                            x: boxes[1].x - 6,
                            y: boxes[1].y - 6,
                            sizeX: boxes[1].sizeX + 12,
                            sizeY: boxes[1].sizeY + 12,
                        },
                    ],
                },
            ];

            let roads = [
                { x: 30, y: 450, width: 500, height: 40, selected: false, resizing: false, color: 'darkgrey' }, // Horizontal road
                { x: 600, y: 50, width: 40, height: 300, selected: false, resizing: false, color: 'darkgrey' }, // Vertical road
            ];

            let gates = [
                { name: 'Main Gate', x: 250, y: 500, selected: false, vertical: false }, // Horizontal gate
                { name: 'Side Gate', x: 680, y: 100, selected: false, vertical: true }, // Vertical gate
            ];

            let railways = [
                { x: 30, y: 600, width: 600, height: 5, selected: false, resizing: false }, // Railway track
            ];

            document.enableCanvas = function (boxesString, zonesString, roadsString, gatesString, railwaysString) {
                zones = JSON.parse(zonesString) || [];
                roads = JSON.parse(roadsString) || [];
                gates = JSON.parse(gatesString) || [];
                railways = JSON.parse(railwaysString) || [];
                boxes = JSON.parse(boxesString);
                enableCanvas(boxes, zones, roads, gates, railways);
            };

            document.createZone = function (zoneName, zoneType, zoneColor) {
                createZoneAroundSelectedBoxes(zoneName, zoneType, zoneColor);
            };

            document.removeZone = function () {
                removeZoneBySelectedBox();
            };

            document.removeBoxInZone = function () {
                removeBoxInZone();
            };

            document.createRoad = function () {
                createRoad();
            };

            document.removeRoad = function () {
                removeRoad();
            };

            document.createGate = function (name) {
                createGate(name);
            };

            document.removeGate = function () {
                removeGate();
            };

            document.createRailWay = function () {
                createRailway();
            };

            document.removeRailWay = function () {
                removeRailWay();
            };

            document.createBox = function (name) {
                createBox(name);
            };

            document.removeBox = function () {
                const data = removeBox();
                return JSON.stringify(data);
            };

            document.addTotal = function (total, guid) {
                addTotal(total, guid);
            };

            document.changeDimensionless = function (dimensionless) {
                changeDimensionless(dimensionless);
            };

            document.getDatas = function () {
                const data = getDatas();
                return JSON.stringify(data);
            };

            document.checkTotal = function () {
                const boxWithOutTotal = checkTotal();
                return JSON.stringify(boxWithOutTotal);
            };

            document.notInZones = function () {
                const boxNotInZones = notInZones();
                return JSON.stringify(boxNotInZones);
            };

            function enableCanvas(boxesFrom1C, zonesFrom1C, roadsFrom1C, gatesFrom1C, railwaysFrom1C) {
                boxes = boxesFrom1C;
                zones = zonesFrom1C ? zonesFrom1C : [];
                roads = roadsFrom1C ? roadsFrom1C : [];
                gates = gatesFrom1C ? gatesFrom1C : [];
                railways = railwaysFrom1C ? railwaysFrom1C : [];
                const imgHor = new Image();
                const imgVer = new Image();
                const canvas = document.getElementById('myCanvas');
                const ctx = canvas.getContext('2d');
                imgHor.src =
                    'data:image/svg+xml;base64,' +
                    btoa(`
                        <svg width="137" height="18" viewBox="0 0 137 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="1" y="1" width="47" height="16" rx="2" stroke="#E69557" stroke-width="2" />
                        <rect x="90" y="1" width="46" height="16" rx="2" stroke="#E69557" stroke-width="2" />
                        <line x1="28" y1="17" x2="58" y2="17" stroke="black" stroke-width="2" stroke-linecap="round" />
                        <line x1="76" y1="17" x2="112" y2="17" stroke="black" stroke-width="2" stroke-linecap="round" />
                        </svg>
                        `);
                imgVer.src =
                    'data:image/svg+xml;base64,' +
                    btoa(`
                        <svg width="18" height="137" viewBox="0 0 18 137" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="17" y="1" width="47" height="16" rx="2" transform="rotate(90 17 1)" stroke="#E69557" stroke-width="2"/>
                        <rect x="17" y="90" width="46" height="16" rx="2" transform="rotate(90 17 90)" stroke="#E69557" stroke-width="2"/>
                        <line x1="1" y1="28" x2="0.999999" y2="58" stroke="black" stroke-width="2" stroke-linecap="round"/>
                        <line x1="1" y1="76" x2="0.999995" y2="112" stroke="black" stroke-width="2" stroke-linecap="round"/>
                        </svg>

                        `);
                let isDragging = false;
                let isResizing = false;
                let resizeDirection = null;
                let dragStartPosition = [];
                let selectedType = null; // Новый флаг, который будет определять, что мы перетаскиваем

                draw();

                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const drawnNames = new Set();
                    for (let i = 0; i < zones.length; i++) {
                        // if (!drawnNames.has(zones[i].name)) {
                        ctx.fillStyle = zones[i].color;
                        ctx.fillRect(10, 1000 + i * 20, 15, 15);
                        ctx.fillStyle = 'black';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`- ${zones[i].name}`, 35, 1010 + i * 20);
                        // drawnNames.add(zones[i].name);
                        // }
                    }

                    // Рисуем дороги
                    if (roads.length > 0) {
                        roads.forEach((road) => {
                            // Отрисовка заливки дороги
                            ctx.fillStyle = road.color;
                            ctx.fillRect(road.x, road.y, road.width, road.height);

                            // Настройка внешней обводки
                            ctx.lineWidth = 0.5;
                            ctx.strokeStyle = road.selected ? '#033a91' : 'black';
                            ctx.strokeRect(road.x, road.y, road.width, road.height);

                            // Отрисовка квадратного элемента для манипуляций
                            ctx.fillRect(road.x + road.width - 5, road.y + road.height - 5, 5, 5);

                            // Настройка пунктира для центральной линии
                            ctx.setLineDash([5, 5]); // Длина штриха и промежутка
                            ctx.strokeStyle = 'white'; // Белая пунктирная линия

                            if (road.width > road.height) {
                                // Горизонтальная дорога - пунктирная линия по центру по вертикали
                                const centerY = road.y + road.height / 2;
                                ctx.beginPath();
                                ctx.moveTo(road.x, centerY);
                                ctx.lineTo(road.x + road.width, centerY);
                                ctx.stroke();
                            } else {
                                // Вертикальная дорога - пунктирная линия по центру по горизонтали
                                const centerX = road.x + road.width / 2;
                                ctx.beginPath();
                                ctx.moveTo(centerX, road.y);
                                ctx.lineTo(centerX, road.y + road.height);
                                ctx.stroke();
                            }

                            // Сброс пунктира для дальнейших отрисовок
                            ctx.setLineDash([]);
                        });
                    }

                    if (railways.length > 0) {
                        railways.forEach((railway) => {
                            const tieWidth = 10; // Ширина шпал
                            const tieHeight = 60; // Высота шпал
                            const tieGap = 30; // Расстояние между шпалами
                            ctx.beginPath();
                            ctx.moveTo(railway.x, railway.y); // Верхний рельс
                            ctx.lineTo(railway.x + railway.width, railway.y);
                            ctx.moveTo(railway.x, railway.y + 40); // Нижний рельс
                            ctx.lineTo(railway.x + railway.width, railway.y + 40);
                            ctx.lineWidth = railway.height;
                            ctx.strokeStyle = 'gray';
                            ctx.stroke();

                            for (let i = 0; i <= railway.width / tieGap; i++) {
                                const currentX = railway.x + i * tieGap;
                                ctx.fillStyle = 'brown';
                                ctx.fillRect(currentX, railway.y - 10, tieWidth, tieHeight);
                            }
                        });
                    }

                    // Рисуем ворота
                    if (gates.length > 0) {
                        gates.forEach((gate) => {
                            const gateWidth = 137;
                            const gateHeight = 18;
                            const gateColor = gate.selected ? '#033a91' : 'black';

                            ctx.save();
                            ctx.fillStyle = gateColor;
                            ctx.font = '14px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';

                            if (!gate.vertical) {
                                ctx.drawImage(imgHor, gate.x, gate.y, gateWidth, gateHeight);
                                ctx.fillText(gate.name, gate.x + gateWidth / 2, gate.y - 10);
                            } else {
                                ctx.drawImage(imgVer, gate.x, gate.y, gateHeight, gateWidth);
                                const textX = gate.x - 10;
                                const textY = gate.y + gateWidth / 2;

                                ctx.translate(textX, textY);
                                ctx.rotate(-Math.PI / 2);
                                ctx.fillText(gate.name, 0, 0);
                            }

                            ctx.restore();
                        });
                    }
                    console.log(zones);

                    // Затем рисуем боксы
                    boxes.forEach((box) => {
                        for (let i = 0; i < zones.length; i++) {
                            for (let j = 0; j < zones[i].boxes.length; j++) {
                                if (zones[i].boxes[j].name === box.name) {
                                    boxInZone = zones[i].boxes[j];
                                    ctx.fillStyle = zones[i].color;
                                    ctx.fillRect(boxInZone.x, boxInZone.y, boxInZone.sizeX, boxInZone.sizeY);
                                }
                            }
                        }
                        ctx.fillStyle = box.selected ? 'orange' : box.color;
                        ctx.fillRect(box.x, box.y, box.sizeX, box.sizeY);

                        // Устанавливаем цвет границы для каждого бокса
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'black';
                        if (box.selected) {
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = '#033a91';
                        }
                        // Рисуем обводку (границу) каждого бокса
                        ctx.strokeRect(box.x, box.y, box.sizeX, box.sizeY);

                        // Настройка пунктира для центральной линии
                        if (box.total > 0) {
                            ctx.setLineDash([0, 0]); // Длина штриха и промежутка
                            ctx.strokeStyle = 'white'; // Белая пунктирная линия

                            const centerY = box.y + box.sizeY / 1.6;
                            ctx.beginPath();
                            ctx.moveTo(box.x + 20, centerY);
                            ctx.lineTo(box.x + box.sizeX - 20, centerY);
                            ctx.stroke();
                        }

                        switch (box.operationType) {
                            case 'input':
                                // Цвет стрелки
                                ctx.strokeStyle = '#36fa05';
                                ctx.fillStyle = '#36fa05';
                                ctx.lineWidth = 4;

                                // Начальные и конечные координаты
                                const startX = box.x + 15;
                                const startY = box.y + 5;
                                const endX = box.x + 15;
                                const endY = box.y + 30;

                                // Длина и угол наклона наконечника стрелки
                                const arrowHeadLength = 15;
                                const angle = Math.PI / 5; // 30 градусов

                                // Основная линия стрелки
                                ctx.beginPath();
                                ctx.moveTo(startX, startY);
                                ctx.lineTo(endX, endY - 12);
                                ctx.stroke();

                                // Наконечник стрелки
                                const angle1 = Math.atan2(endY - startY, endX - startX) + angle;
                                const angle2 = Math.atan2(endY - startY, endX - startX) - angle;

                                ctx.beginPath();
                                ctx.moveTo(endX, endY);
                                ctx.lineTo(
                                    endX - arrowHeadLength * Math.cos(angle1),
                                    endY - arrowHeadLength * Math.sin(angle1)
                                );
                                ctx.lineTo(
                                    endX - arrowHeadLength * Math.cos(angle2),
                                    endY - arrowHeadLength * Math.sin(angle2)
                                );
                                ctx.closePath();
                                ctx.fill();
                                break;
                            case 'output':
                                ctx.strokeStyle = '#fa0505';
                                ctx.fillStyle = '#fa0505';
                                ctx.lineWidth = 4;

                                const startXOutput = box.x + 15;
                                const startYOutput = box.y + 32;

                                // Конечная точка стрелки
                                const endXOutput = box.x + 15;
                                const endYOutput = box.y + 3;

                                // Длина и угол наклона наконечника стрелки
                                const arrowHeadLengthOutput = 17;
                                const angleOutput = Math.PI / 6; // 30 градусов

                                // Основная линия стрелки
                                ctx.beginPath();
                                ctx.moveTo(startXOutput, startYOutput);
                                ctx.lineTo(endXOutput, endYOutput + 10);
                                ctx.stroke();

                                // Кончик стрелки как заполненный треугольник
                                const angle1Output =
                                    Math.atan2(endYOutput - startYOutput, endXOutput - startXOutput) + angleOutput;
                                const angle2Output =
                                    Math.atan2(endYOutput - startYOutput, endXOutput - startXOutput) - angleOutput;

                                ctx.beginPath();
                                ctx.moveTo(endXOutput, endYOutput);
                                ctx.lineTo(
                                    endXOutput - arrowHeadLengthOutput * Math.cos(angle1Output),
                                    endYOutput - arrowHeadLengthOutput * Math.sin(angle1Output)
                                );
                                ctx.lineTo(
                                    endXOutput - arrowHeadLengthOutput * Math.cos(angle2Output),
                                    endYOutput - arrowHeadLengthOutput * Math.sin(angle2Output)
                                );
                                ctx.closePath();
                                ctx.fill();
                            default:
                                break;
                        }

                        ctx.fillStyle = 'white';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        if (box.dimensionless) {
                            ctx.fillText(` ${box.name}*`, box.x + box.sizeX / 2, box.y + box.sizeY / 2);
                        } else {
                            ctx.fillText(box.name, box.x + box.sizeX / 2, box.y + box.sizeY / 2);
                        }
                        if ((box.total > 0 && box.available > 0) || (box.total > 0 && box.unavailable > 0)) {
                            ctx.fillText(
                                `${box.available} / ${box.total}`,
                                box.x + box.sizeX / 2,
                                box.y + box.sizeY / 1.3
                            );
                        } else if (box.total > 0) {
                            ctx.fillText(`${box.total}`, box.x + box.sizeX / 2, box.y + box.sizeY / 1.3);
                        }
                        ctx.fillStyle = 'black';
                        ctx.fillRect(box.x + box.sizeX - 5, box.y + box.sizeY - 5, 5, 5);
                    });
                }

                function isOnRightResizeHandle(box, mouseX, mouseY) {
                    return (
                        mouseX > box.x + box.sizeX - 10 &&
                        mouseX < box.x + box.sizeX &&
                        mouseY > box.y &&
                        mouseY < box.y + box.sizeY - 10
                    );
                }

                function isOnBottomResizeHandle(box, mouseX, mouseY) {
                    return (
                        mouseX > box.x &&
                        mouseX < box.x + box.sizeX - 10 &&
                        mouseY > box.y + box.sizeY - 10 &&
                        mouseY < box.y + box.sizeY
                    );
                }

                function isOnCornerResizeHandle(box, mouseX, mouseY) {
                    return (
                        mouseX > box.x + box.sizeX - 10 &&
                        mouseX < box.x + box.sizeX &&
                        mouseY > box.y + box.sizeY - 10 &&
                        mouseY < box.y + box.sizeY
                    );
                }

                function isOnRightResizeHandleRoad(road, mouseX, mouseY) {
                    return (
                        mouseX > road.x + road.width - 10 &&
                        mouseX < road.x + road.width &&
                        mouseY > road.y &&
                        mouseY < road.y + road.height - 10
                    );
                }

                function isOnBottomResizeHandleRoad(road, mouseX, mouseY) {
                    return (
                        mouseX > road.x &&
                        mouseX < road.x + road.width - 10 &&
                        mouseY > road.y + road.height - 10 &&
                        mouseY < road.y + road.height
                    );
                }

                function isOnCornerResizeHandleRoad(road, mouseX, mouseY) {
                    return (
                        mouseX > road.x + road.width - 10 &&
                        mouseX < road.x + road.width &&
                        mouseY > road.y + road.height - 10 &&
                        mouseY < road.y + road.height
                    );
                }

                function isOnRightResizeHandleRailway(railway, mouseX, mouseY) {
                    return (
                        mouseX > railway.x + railway.width - 10 &&
                        mouseX < railway.x + railway.width &&
                        mouseY > railway.y &&
                        mouseY < railway.y + 50
                    );
                }

                canvas.addEventListener('mousedown', (e) => {
                    const mouseX = e.offsetX,
                        mouseY = e.offsetY;

                    isResizing = false;
                    resizeDirection = null;
                    selectedType = null;

                    roads.forEach((road) => {
                        if (isOnCornerResizeHandleRoad(road, mouseX, mouseY)) {
                            road.resizing = true;
                            isResizing = true;
                            resizeDirection = 'corner';
                            selectedType = 'road';
                        } else if (isOnRightResizeHandleRoad(road, mouseX, mouseY)) {
                            road.resizing = true;
                            isResizing = true;
                            resizeDirection = 'right';
                            selectedType = 'road';
                        } else if (isOnBottomResizeHandleRoad(road, mouseX, mouseY)) {
                            road.resizing = true;
                            isResizing = true;
                            resizeDirection = 'bottom';
                            selectedType = 'road';
                        } else {
                            road.resizing = false;
                        }
                    });

                    // Проверяем, выбрана ли дорога
                    roads.forEach((road) => {
                        if (
                            mouseX > road.x &&
                            mouseX < road.x + road.width &&
                            mouseY > road.y &&
                            mouseY < road.y + road.height
                        ) {
                            road.selected = true;
                            selectedType = 'road'; // Устанавливаем тип выделенного объекта как "дорога"
                            canvas.style.cursor = 'move';
                            dragStartPosition = [{ road, offsetX: mouseX - road.x, offsetY: mouseY - road.y }];
                            isDragging = true;
                        } else {
                            road.selected = false;
                        }
                    });

                    railways.forEach((railway) => {
                        if (isOnRightResizeHandleRailway(railway, mouseX, mouseY)) {
                            railway.resizing = true;
                            isResizing = true;
                            resizeDirection = 'right';
                            selectedType = 'railway';
                        } else {
                            railway.resizing = false;
                        }
                    });

                    railways.forEach((railway) => {
                        if (
                            mouseX > railway.x &&
                            mouseX < railway.x + railway.width &&
                            mouseY > railway.y &&
                            mouseY < railway.y + 50
                        ) {
                            railway.selected = true;
                            selectedType = 'railway'; // Устанавливаем тип выделенного объекта как "дорога"
                            canvas.style.cursor = 'move';
                            dragStartPosition = [{ railway, offsetX: mouseX - railway.x, offsetY: mouseY - railway.y }];
                            isDragging = true;
                        } else {
                            railway.selected = false;
                        }
                    });

                    // Проверяем, выбрали ли квадрат
                    boxes.forEach((box) => {
                        if (!box.locked && !box.inZone && isOnCornerResizeHandle(box, mouseX, mouseY)) {
                            box.resizing = true;
                            isResizing = true;
                            resizeDirection = 'corner';
                            selectedType = 'box'; // Устанавливаем тип выделенного объекта как "квадрат"
                        } else if (!box.locked && !box.inZone && isOnRightResizeHandle(box, mouseX, mouseY)) {
                            box.resizing = true;
                            isResizing = true;
                            resizeDirection = 'right';
                            selectedType = 'box';
                        } else if (!box.locked && !box.inZone && isOnBottomResizeHandle(box, mouseX, mouseY)) {
                            box.resizing = true;
                            isResizing = true;
                            resizeDirection = 'bottom';
                            selectedType = 'box';
                        } else {
                            box.resizing = false;
                        }
                    });

                    if (isResizing) {
                        canvas.style.cursor =
                            resizeDirection === 'corner'
                                ? 'nwse-resize'
                                : resizeDirection === 'right'
                                  ? 'ew-resize'
                                  : 'ns-resize';
                        return;
                    }

                    boxes.forEach((box) => {
                        if (!box.locked) {
                            if (
                                mouseX > box.x &&
                                mouseX < box.x + box.sizeX &&
                                mouseY > box.y &&
                                mouseY < box.y + box.sizeY
                            ) {
                                box.selected = true;
                                selectedType = 'box';
                                canvas.style.cursor = 'move';
                            } else if (!e.shiftKey) {
                                box.selected = false;
                            }
                        }
                    });

                    gates.forEach((gate) => {
                        if (!gate.vertical) {
                            // Если ворота не повёрнуты (вертикальные)
                            if (mouseX > gate.x && mouseX < gate.x + 137 && mouseY > gate.y && mouseY < gate.y + 18) {
                                gate.selected = true;
                                selectedType = 'gate'; // Устанавливаем тип как 'gate'
                                canvas.style.cursor = 'move';
                                dragStartPosition = [{ gate, offsetX: mouseX - gate.x, offsetY: mouseY - gate.y }];
                                isDragging = true;
                            } else {
                                gate.selected = false;
                            }
                        } else {
                            // Если ворота повёрнуты (горизонтальные)
                            if (mouseX > gate.x && mouseX < gate.x + 18 && mouseY > gate.y && mouseY < gate.y + 137) {
                                gate.selected = true;
                                selectedType = 'gate'; // Устанавливаем тип как 'gate'
                                canvas.style.cursor = 'move';
                                dragStartPosition = [{ gate, offsetX: mouseX - gate.x, offsetY: mouseY - gate.y }];
                                isDragging = true;
                            } else {
                                gate.selected = false;
                            }
                        }
                    });
                    if (selectedType === 'box') {
                        dragStartPosition = boxes
                            .filter((box) => box.selected)
                            .map((box) => ({ box, offsetX: mouseX - box.x, offsetY: mouseY - box.y }));
                    } else if (selectedType === 'road') {
                        dragStartPosition = roads
                            .filter((road) => road.selected)
                            .map((road) => ({ road, offsetX: mouseX - road.x, offsetY: mouseY - road.y }));
                    } else if (selectedType === 'gate') {
                        dragStartPosition = gates
                            .filter((gate) => gate.selected)
                            .map((gate) => ({ gate, offsetX: mouseX - gate.x, offsetY: mouseY - gate.y }));
                    } else if (selectedType === 'railway') {
                        dragStartPosition = railways
                            .filter((railway) => railway.selected)
                            .map((railway) => ({ railway, offsetX: mouseX - railway.x, offsetY: mouseY - railway.y }));
                    }
                    isDragging = dragStartPosition.length > 0;
                    draw();
                });

                canvas.addEventListener('mousemove', (e) => {
                    const mouseX = e.offsetX;
                    const mouseY = e.offsetY;

                    if (isResizing && selectedType === 'box') {
                        boxes.forEach((box) => {
                            if (box.resizing) {
                                if (resizeDirection === 'corner') {
                                    const newSizeX = mouseX - box.x;
                                    const newSizeY = mouseY - box.y;
                                    box.sizeX = Math.max(20, newSizeX);
                                    box.sizeY = Math.max(20, newSizeY);
                                } else if (resizeDirection === 'right') {
                                    const newSizeX = mouseX - box.x;
                                    box.sizeX = Math.max(20, newSizeX);
                                } else if (resizeDirection === 'bottom') {
                                    const newSizeY = mouseY - box.y;
                                    box.sizeY = Math.max(20, newSizeY);
                                }
                            }
                        });

                        draw();
                        return;
                    }

                    if (isResizing && selectedType === 'road') {
                        roads.forEach((road) => {
                            if (road.resizing) {
                                if (resizeDirection === 'corner') {
                                    const newSizeX = mouseX - road.x;
                                    const newSizeY = mouseY - road.y;
                                    road.width = Math.max(20, newSizeX);
                                    road.height = Math.max(20, newSizeY);
                                } else if (resizeDirection === 'right') {
                                    const newSizeX = mouseX - road.x;
                                    road.width = Math.max(20, newSizeX);
                                } else if (resizeDirection === 'bottom') {
                                    const newSizeY = mouseY - road.y;
                                    road.height = Math.max(20, newSizeY);
                                }
                            }
                        });

                        draw();
                        return;
                    }

                    if (isResizing && selectedType === 'railway') {
                        railways.forEach((railway) => {
                            if (railway.resizing) {
                                if (resizeDirection === 'right') {
                                    const newSizeX = mouseX - railway.x;
                                    railway.width = Math.max(20, newSizeX);
                                }
                            }
                        });

                        draw();
                        return;
                    }

                    if (!isDragging) return;
                    if (selectedType === 'box') {
                        dragStartPosition.forEach(({ box, offsetX, offsetY }) => {
                            const newX = mouseX - offsetX;
                            const newY = mouseY - offsetY;

                            // Если квадрат не заблокирован зоной, проверяем только коллизии с другими квадратами и с внешними границами зоны
                            if (!box.inZone) {
                                if (
                                    !checkCollisionWithBoxes(box, newX, newY, box.sizeX, box.sizeY) &&
                                    !checkCollisionWithZoneBorders(newX, newY, box.sizeX, box.sizeY)
                                ) {
                                    box.x = newX;
                                    box.y = newY;
                                }
                            }
                        });
                    }

                    if (selectedType === 'road') {
                        dragStartPosition.forEach(({ road, offsetX, offsetY }) => {
                            const newX = mouseX - offsetX;
                            const newY = mouseY - offsetY;

                            // Перемещение дороги
                            road.x = newX;
                            road.y = newY;
                        });
                    }
                    if (selectedType === 'railway') {
                        dragStartPosition.forEach(({ railway, offsetX, offsetY }) => {
                            const newX = mouseX - offsetX;
                            const newY = mouseY - offsetY;

                            // Перемещение дороги
                            railway.x = newX;
                            railway.y = newY;
                        });
                    }

                    if (selectedType === 'gate') {
                        dragStartPosition.forEach(({ gate, offsetX, offsetY }) => {
                            let newX, newY;

                            if (gate.vertical) {
                                // Если ворота повернуты (горизонтальные), смещение для перемещения будет другим
                                newX = mouseX - offsetX;
                                newY = mouseY - offsetY;

                                // Поменять координаты относительно центра поворота
                                if (
                                    newX >= 0 &&
                                    newX + 18 <= canvas.width &&
                                    newY >= 0 &&
                                    newY + 137 <= canvas.height
                                ) {
                                    gate.x = newX;
                                    gate.y = newY;
                                }
                            } else {
                                // Для вертикальных ворот
                                newX = mouseX - offsetX;
                                newY = mouseY - offsetY;

                                if (
                                    newX >= 0 &&
                                    newX + 137 <= canvas.width &&
                                    newY >= 0 &&
                                    newY + 18 <= canvas.height
                                ) {
                                    gate.x = newX;
                                    gate.y = newY;
                                }
                            }
                        });

                        draw();
                    }

                    draw();
                });

                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                    isResizing = false;
                    resizeDirection = null;
                    boxes.forEach((box) => (box.resizing = false));
                    canvas.style.cursor = 'default';
                });

                canvas.addEventListener('dblclick', (e) => {
                    const mouseX = e.offsetX;
                    const mouseY = e.offsetY;
                    boxes.forEach((box) => {
                        if (box.selected) {
                            box.selected = false;
                        }
                    });
                    roads.forEach((road) => {
                        if (road.selected) {
                            roads.forEach((road) => {
                                if (
                                    mouseX > road.x &&
                                    mouseX < road.x + road.width &&
                                    mouseY > road.y &&
                                    mouseY < road.y + road.height
                                ) {
                                    // Меняем ширину и высоту для поворота на 90 градусов
                                    [road.width, road.height] = [road.height, road.width];
                                    draw(); // Перерисовываем canvas
                                }
                            });
                        }
                    });
                    gates.forEach((gate) => {
                        if (gate.selected) {
                            gate.vertical = !gate.vertical;
                            gate.selected = false;
                        }
                    });
                    draw();
                });
            }

            // Проверка на коллизию боксов с другими боксами
            function checkCollisionWithBoxes(box, newX, newY, newSizeX, newSizeY) {
                for (let i = 0; i < boxes.length; i++) {
                    const otherBox = boxes[i];
                    if (otherBox !== box) {
                        if (
                            newX < otherBox.x + otherBox.sizeX &&
                            newX + newSizeX > otherBox.x &&
                            newY < otherBox.y + otherBox.sizeY &&
                            newY + newSizeY > otherBox.y
                        ) {
                            return true; // Есть коллизия
                        }
                    }
                }
                return false; // Нет коллизии с боксами
            }

            // Проверка на коллизию с внешними границами зоны
            function checkCollisionWithZoneBorders(newX, newY, newSizeX, newSizeY) {
                for (let i = 0; i < zones.length; i++) {
                    const zone = zones[i];
                    for (let j = 0; j < zone.boxes.length; j++) {
                        const box = zone.boxes[j];
                        if (
                            newX < box.x + box.sizeX &&
                            newX + newSizeX > box.x &&
                            newY < box.y + box.sizeY &&
                            newY + newSizeY > box.y
                        ) {
                            return true; // Есть коллизия с внутренними границами зоны
                        }
                    }
                }

                return false; // Нет коллизии с внешними границами зоны
            }

            // Функция удаления квадрата из зоны
            function removeBoxInZone() {
                const selectedBox = boxes.find((box) => box.selected);
                if (selectedBox) {
                    for (let i = zones.length - 1; i >= 0; i--) {
                        const zone = zones[i];
                        const index = zone.boxes.findIndex((box) => box.name === selectedBox.name);

                        if (index !== -1) {
                            // Удаляем box из текущей zone
                            zone.boxes.splice(index, 1);

                            // Если больше нет box в zone, удаляем саму zone
                            if (zone.boxes.length === 0) {
                                zones.splice(i, 1);
                            }
                        }
                    }

                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }

            // Функция удаления зоны по выделенному квадрату
            function removeZoneBySelectedBox() {
                const selectedBox = boxes.find((box) => box.selected);
                if (selectedBox) {
                    // Найти индекс зоны, которая содержит выбранный box
                    const zoneIndex = zones.findIndex((zone) =>
                        zone.boxes.some((box) => box.name === selectedBox.name)
                    );

                    // Если такая зона найдена, удалить её из массива zones
                    if (zoneIndex !== -1) {
                        zones.splice(zoneIndex, 1);
                    }

                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }
            // Функция генерации случайного цвета
            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }

            // Создаем новую зону вокруг выбранных боксов
            function createZoneAroundSelectedBoxes(zoneName, zoneType, zoneColor) {
                const randomColor = getRandomColor();

                let selectedBoxNames = [];

                boxes.forEach((box) => {
                    if (box.selected) {
                        box.inZone = true;
                        selectedBoxNames.push({
                            name: box.name,
                            x: box.x - 6,
                            y: box.y - 6,
                            sizeX: box.sizeX + 12,
                            sizeY: box.sizeY + 12,
                        });
                    }
                });

                // Проходим по всем зонам
                for (const zone of zones) {
                    // Проверяем, содержит ли зона хотя бы один из выделенных боксов
                    if (
                        zone.boxes.some((box) => selectedBoxNames.some((selectedBox) => selectedBox.name === box.name))
                    ) {
                        // Находим боксы из selectedBoxNames, которые еще не находятся в этой зоне
                        const newBoxes = selectedBoxNames.filter(
                            (selectedBox) => !zone.boxes.some((box) => box.name === selectedBox.name)
                        );

                        // Добавляем новые боксы в зону
                        zone.boxes.push(...newBoxes);

                        // Удаляем добавленные боксы из selectedBoxNames
                        selectedBoxNames = [];
                    }
                }

                for (const zone of zones) {
                    if (zone.name === zoneName) {
                        const boxess = [...zone.boxes, ...selectedBoxNames];
                        zone.boxes = boxess;
                        enableCanvas(boxes, zones, roads, gates, railways);
                        return;
                    }
                }

                if (selectedBoxNames.length === 0) {
                    enableCanvas(boxes, zones, roads, gates, railways);
                    return;
                } else {
                    const zone = {
                        name: zoneName,
                        type: zoneType,
                        color: zoneColor || randomColor,
                        boxes: selectedBoxNames,
                    };

                    zones.push(zone);
                }
                enableCanvas(boxes, zones, roads, gates, railways);
            }

            function createRoad() {
                const road = {
                    x: 0, // начальные координаты
                    y: 0,
                    width: 200, // ширина
                    height: 10, // высота
                    selected: false,
                    resizing: false,
                    color: 'gray',
                };
                roads.push(road);
                enableCanvas(boxes, zones, roads, gates, railways);
            }

            function removeRoad() {
                const selectedRoad = roads.find((road) => road.selected);
                if (selectedRoad) {
                    const roadIndex = roads.findIndex((road) => road.selected);
                    if (roadIndex !== -1) {
                        roads.splice(roadIndex, 1); // Удаляем дорогу
                    }
                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }

            function createGate(name) {
                const gate = {
                    name: name,
                    x: 0,
                    y: 0,
                    selected: false,
                    vertical: false,
                };
                gates.push(gate);
                enableCanvas(boxes, zones, roads, gates, railways);
            }

            function removeGate() {
                const selectedGate = gates.find((gate) => gate.selected);
                if (selectedGate) {
                    const gateIndex = gates.findIndex((gate) => gate.selected);
                    if (gateIndex !== -1) {
                        gates.splice(gateIndex, 1); // Удаляем ворота
                    }
                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }

            function createRailway() {
                const railway = {
                    x: 0,
                    y: 10,
                    width: 100,
                    height: 10,
                    selected: false,
                    resizing: false,
                };
                railways.push(railway);
                enableCanvas(boxes, zones, roads, gates, railways);
            }

            function removeRailway() {
                const selectedRailway = railways.find((railway) => railway.selected);
                if (selectedRailway) {
                    const railwayIndex = railways.findIndex((railway) => railway.selected);
                    if (railwayIndex !== -1) {
                        railways.splice(railwayIndex, 1);
                    }
                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }

            function createBox(name) {
                const box = {
                    name: name,
                    initialvalue: 1,
                    finalvalue: 12,
                    x: 0,
                    y: 0,
                    sizeX: 100,
                    sizeY: 100,
                    selected: false,
                    resizing: false,
                    locked: false,
                    color: 'green',
                    available: 0,
                    unavailable: 0,
                    total: 0,
                    TypeGUID: '',
                    operationType: '',
                    inZone: false,
                };
                boxes.push(box);
                enableCanvas(boxes, zones, roads, gates, railways);
            }

            function removeBox() {
                const selectedBox = boxes.find((box) => box.selected);
                if (selectedBox) {
                    const boxIndex = boxes.findIndex((box) => box.selected);
                    if (boxIndex !== -1) {
                        boxes.splice(boxIndex, 1);
                    }
                    enableCanvas(boxes, zones, roads, gates, railways);
                }
                return selectedBox;
            }

            function getDatas() {
                const data = { boxes, zones, roads, gates, railways };

                return data;
            }

            function addTotal(total, guid) {
                if (typeof total !== 'number') {
                    parseInt(total);
                }
                const selectedBoxes = boxes.filter((box) => box.selected);

                if (selectedBoxes.length > 0) {
                    for (selectedBox of selectedBoxes) {
                        const box = boxes.find((b) => b.name === selectedBox.name);
                        box.TypeGUID = guid;
                        box.total = total;
                    }
                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }

            function changeDimensionless(dimensionless) {
                const selectedBoxes = boxes.filter((box) => box.selected);
                if (selectedBoxes.length > 0) {
                    for (selectedBox of selectedBoxes) {
                        const box = boxes.find((b) => b.name === selectedBox.name);
                        box.dimensionless = dimensionless;
                    }
                    enableCanvas(boxes, zones, roads, gates, railways);
                }
            }

            function checkTotal() {
                const box = boxes.filter((box) => box.total === 0);
                return box;
            }

            function notInZones() {
                const box = boxes.filter((box) => box.inZone === false);
                return box;
            }

            enableCanvas(boxes, zones, roads, gates, railways);
        </script>
    </body>
</html>
